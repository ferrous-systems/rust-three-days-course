# Ownership

Ownership ist die Basis fÃ¼r das Speichermanagement von Rust.

---

## Regeln

-   Jedes StÃ¼ck Daten wird genau einmal besessen
-   Besitz kann abgegeben werden
-   Der Besitzer ist fÃ¼r das Entfernen der Daten aus dem Speicher verantwortlich.
-   Der Besitzer hat volle Gewalt Ã¼ber die Daten und kann sie mutieren

---

Diese Regeln: \* sind fundamental fÃ¼r Rusts Typsystem! \* werden beim Ãœbersetzen angewandt. \* sind aber auch sonst praktisch.

---

## Beispiel

<pre><code data-source="chapters/shared/code/ownership/1.rs" data-trim="hljs rust" class="lang-rust"></code> class="lang-rust" class="lang-rust" class="lang-rust" class="lang-rust"</pre>

---

<pre class="diagram">
    main              pacman
+----------+
|          |
|    dot   |---+
|          |   |
+----------+   |    +----------+
               |    |          |
               +----|   dot    |
                    |          |
                    +----------+

                      ğŸ—‘
</pre>

---

Was passiert, wenn versuchen, `dot` nochmal zu verwenden?

---

<pre><code data-source="chapters/shared/code/ownership/2.rs" data-trim="hljs rust" class="lang-rust"></code></pre>

---

## Oops!

---

Dieser Vorgang nennt sich im Rust-Lingo `konsumieren`. `pacman` konsumiert `dot`.

Danach kann der Wert nicht mehr verwendet werden.

---

## Hintergrund

Wen wir `pacman` mit `dot` aufrufen, werden die Daten in die Argumente von `pacman` bewegt (move). Dabei geht der Besitz an `pacman` Ã¼ber. `main` besitzt die Daten danach nicht mehr und darf sie auch nicht mehr manipulieren.

---

## Mit moves umgehen: explizit klonen

Was tun, wenn dieses Verhalten nicht erwÃ¼nscht ist? Wir kÃ¶nnen eine zweite Version der Daten anlegen!

---

<pre><code data-source="chapters/shared/code/ownership/3.rs" data-trim="hljs rust" class="lang-rust"></code></pre>

---

<pre class="diagram">
    main              pacman
+----------+
|          |
|    dot   |-=-+
|          |   |
+----------+   :    +----------+
     |         |    |          |
     |         +=-=-|   dot    |
     |              |          |
     |              +----------+
     |
     |                ğŸ—‘
     |
+----------+
|          |
|  clone   |-=-+
|          |   |
+----------+   :    +----------+
               |    |          |
               +-=-=|   dot    |
                    |          |
                    +----------+

                      ğŸ—‘

</pre>

---

Klonen ist fÃ¼r Daten vorgesehen, bei denen der Vorgang der Duplizierung komplex ist.

---

## Mit moves umgehen: kopieren statt moves

<pre><code data-source="chapters/shared/code/ownership/4.rs" data-trim="hljs rust" class="lang-rust"></code></pre>

---

Kopien sind fÃ¼r Daten vorgesehen, die im Speicher schnell kopierbar sind (memcopy) und auch kopiert werden dÃ¼rfen (Gegenbeispiel: File-Pointer).

---

Daten, die Copy sind, folgen den Ownership-Regeln, sie werden allerdings kopiert, wenn Ownership abgeben wÃ¼rde.

---

# Warnung

Die Terminologie um moves Ã¤hnelt der von C++, deswegen sollte man die Rust-Terminologie verwenden: Besitz, Besitzabgabe und konsumieren.

---

## Praktisches Beispiel

<pre><code data-source="chapters/shared/code/ownership/5.rs" data-trim="hljs rust"></code></pre>
Was wÃ¼rde passieren, wenn wir File nach dem Aufruf von `use_file` noch verwenden?

---

## Knobelfrage

`drop` ist die Funktion, die einen Wert sofort verwirft. Wie sieht ihre Implementierung aus?

<pre><code data-source="chapters/shared/code/ownership/6.rs" data-trim="hljs rust"></code></pre>

---

<pre><code data-source="chapters/shared/code/ownership/7.rs" data-trim="hljs rust"></code></pre>

